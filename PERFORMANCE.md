# 性能说明

## 📊 性能基准测试

### 测试环境

- **CPU**: Apple M1
- **测试数据**: 100万行关键词库，6MB测试语料
- **Go版本**: 1.20

### 性能对比 (100000个关键词)


| 实现方式                 | 执行时间  | 内存占用 | 分配次数 | 完整性         |
| ------------------------ | --------- | -------- | -------- | -------------- |
| **本库 (AC自动机)**      | **383ms** | 172MB    | 35       | ✅**完整匹配** |
| ayoyu/flashtext (Trie树) | 172ms     | 133MB    | 36       | ❌ 遗漏重叠    |
| 正则表达式 (regexp)      | 22,900ms  | 1MB      | 5,058    | ✅ 完整匹配    |

**核心指标**:

- ⚡ 比正则表达式快 **60倍**
- 🎯 比ayoyu/flashtext慢 **2.2倍**，但**匹配更完整**
- 📦 内存使用合理（172MB用于1000关键词）

---

## 🔍 为什么比其他Go实现慢？

### 算法差异

#### 本库: AC自动机 (Aho-Corasick Automaton)

```
完整的AC自动机算法，包含：
✓ Trie树结构
✓ 失败指针 (Failure Pointer)
✓ 完整的重叠匹配检测
```

#### ayoyu/flashtext: 简化的Trie树

```
基础Trie树实现，不包含：
✗ 无失败指针
✗ 遇到失败直接回根节点
✗ 遗漏重叠匹配
```

### 实际测试对比

**测试用例**: 在文本"hershey"中查找["he", "she", "hers"]

```
本库 (AC自动机) 结果:
  ✓ he    [0:2]   
  ✓ hers  [0:4]   
  ✓ she   [3:6]   ← 重叠匹配
  ✓ he    [4:6]   ← 重叠匹配
总计: 4个匹配

ayoyu/flashtext (Trie树) 结果:
  ✓ he    [0:1]
  ✓ hers  [0:3]
  ✓ he    [4:5]
总计: 3个匹配
❌ 遗漏了 "she"
```

### 性能差距原因

```go
// 本库 - 失败时通过failure指针链查找
for currentNode.children[r] == nil && currentNode.failure != nil {
    currentNode = currentNode.failure  // 额外的指针跳转和遍历
}

// ayoyu - 失败就直接跳过
if child, ok := currentNode.children[r]; ok {
    currentNode = child
} else {
    // 回根节点或跳过，不做额外查找
}
```

**关键点**: 失败指针遍历是AC自动机的核心特性，用于找到所有重叠匹配，这是性能开销的主要来源。

---

## ✨ 我们的优势

### 1. 完整的匹配结果 🎯

**敏感词过滤场景**:

```go
// 关键词: ["习近平", "近平"]
// 文本: "xxx习近平xxx"

// 本库 (AC自动机):
//   ✓ "习近平" [3:12]
//   ✓ "近平"   [6:12]  ← 重叠匹配，可能绕过过滤！

// Trie树实现:
//   ✓ "习近平" [3:12]
//   ✗ 遗漏 "近平"      ← 安全隐患！
```

在安全敏感场景下，遗漏任何一个匹配都可能是严重的问题。

### 2. 算法正确性保证 ✅

- ✅ 标准AC自动机实现
- ✅ 经过完整测试验证
- ✅ 7个测试套件全部通过
- ✅ 包含边缘情况测试

### 3. 比正则表达式快60倍 ⚡

**大规模关键词场景** (1000+关键词):

- 正则表达式: **22秒** (不可用)
- 本库: **0.38秒** (可用)
- 性能提升: **60倍**

### 4. 时间复杂度稳定 📈


| 关键词数量 | 正则表达式 | 本库   |
| ---------- | ---------- | ------ |
| 100        | 1.7秒      | 0.28秒 |
| 1,000      | 22.9秒     | 0.38秒 |
| 10,000     | >5分钟     | ~1秒   |

**关键**: 性能随关键词数量**线性增长**，正则表达式则是**指数增长**。

---

## 🎯 使用场景推荐

### ✅ 选择本库的场景

1. **敏感词过滤/内容审核** - 不能遗漏任何匹配
2. **文本分析/数据挖掘** - 需要完整的匹配结果
3. **关键词数量 > 100** - 正则表达式性能崩溃
4. **重叠匹配检测** - 如检测嵌套的实体名称

### ⚠️ 可考虑其他方案的场景

1. **追求极致性能** - 可接受遗漏重叠匹配
2. **关键词数量 < 50** - 正则表达式仍然可用
3. **非重叠场景** - 如简单的词频统计

---

## 🚀 性能优化建议

### 已实施的优化

- ✅ 预分配切片容量，减少动态扩容
- ✅ 优化BFS队列容量
- ✅ 删除无用字段
- ✅ 减少内存分配（39次→35次）

### 用户可做的优化

```go
// 1. 复用KeywordProcessor实例
kp := NewKeywordProcessor(false)
kp.AddKeywordsFromList(keywords).Build()

// 多次使用同一个实例，避免重复Build
for _, text := range texts {
    matches := kp.ExtractKeywords(text)  // ✓
}

// 2. 对超大文本分块处理
const chunkSize = 1 * 1024 * 1024  // 1MB
for i := 0; i < len(text); i += chunkSize {
    end := min(i+chunkSize, len(text))
    chunk := text[i:end]
    matches := kp.ExtractKeywords(chunk)
    // 处理matches...
}
```

---

## 📝 性能测试命令

### 运行性能对比测试

```bash
# 小规模测试 (100关键词)
go test -bench=BenchmarkSmallScale -benchmem -run=^$

# 中规模测试 (1000关键词)
go test -bench=BenchmarkMediumScale -benchmem -run=^$

# 完整性能测试
go test -bench=. -benchmem -run=^$
```

### 运行完整性验证

```bash
# 验证重叠匹配
go test -v -run=TestAyoyuOverlapMatching

# 功能测试
go test -v -run=^Test
```

---

## 🎬 总结

### 我们的定位

**准确、完整、高性能的AC自动机实现**


| 特性       | 评分       |
| ---------- | ---------- |
| **准确性** | ⭐⭐⭐⭐⭐ |
| **完整性** | ⭐⭐⭐⭐⭐ |
| **性能**   | ⭐⭐⭐⭐   |
| **易用性** | ⭐⭐⭐⭐⭐ |

### 核心价值

在保证**完整匹配**的前提下，提供**接近Trie树**的性能，同时**远超正则表达式**。

### 选择建议

- 如果需要**准确性和完整性** → 选择本库 ✅
- 如果只追求**极致性能** → 考虑简化Trie实现
- 如果关键词少于50个 → 可以考虑正则表达式

**推荐**: 对于大多数场景，本库是**最佳平衡选择**。

---

## 📊 详细性能数据

更多性能测试数据和对比，请查看：

- [性能对比报告](./performance_comparison.md)
- [优化最终报告](./optimization_final_report.md)

## 🤝 贡献

如果你有性能优化建议，欢迎提交 Issue 或 Pull Request！
